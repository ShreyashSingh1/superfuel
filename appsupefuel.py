from baml_client.sync_client import b
import json
import re

def generate_plan(paragraph, tools):
    """Generate a plan with tool calls based on a paragraph and list of tools
    
    Args:
        paragraph (str): The input paragraph text to analyze
        tools (list): List of available tools
        
    Returns:
        dict: A plan with sequence of tool calls
    """
    response = b.AgentPlanner(input={"paragraph": paragraph, "available_tools": tools})
    return response

def execute_plan(plan):
    """Execute a plan generated by the planner
    
    Args:
        plan: Plan with tool calls (BAML response object)
        
    Returns:
        list: Results of each tool call
    """
    results = []
    intermediate_results = {}  # Store intermediate results
    
    # Access tool_calls as an attribute of the plan object
    tool_calls = getattr(plan, "tool_calls", None)
    
    if not tool_calls:
        return ["No tool calls to execute"]
    
    # Execute each tool call in the plan
    for i, tool_call in enumerate(tool_calls):
        tool_name = tool_call.tool_name
        
        try:
            # Clean the parameters string
            param_str = tool_call.parameters
            
            # Try to parse the parameters
            try:
                parameters = json.loads(param_str)
            except json.JSONDecodeError:
                # Clean the string and try again
                cleaned_param_str = param_str.replace('\\"', '"')
                if not cleaned_param_str.startswith('{'):
                    cleaned_param_str = '{' + cleaned_param_str
                if not cleaned_param_str.endswith('}'):
                    cleaned_param_str = cleaned_param_str + '}'
                parameters = json.loads(cleaned_param_str)
            
            # Replace variable references with actual values
            updated_parameters = {}
            for key, value in parameters.items():
                if isinstance(value, str) and value.startswith("result_of"):
                    # This is a reference to a previous result
                    if value in intermediate_results:
                        updated_parameters[key] = intermediate_results[value]
                    else:
                        # If it's the first sum result, use the first result
                        if value == "result_of_first_sum" and len(results) > 0:
                            updated_parameters[key] = results[0]["result"]
                        # If it's the second sum result, use the second result
                        elif value == "result_of_second_sum" and len(results) > 1:
                            updated_parameters[key] = results[1]["result"]
                        else:
                            raise ValueError(f"Unknown reference: {value}")
                else:
                    updated_parameters[key] = value
            
            # Execute the tool with the updated parameters
            result = execute_tool(tool_name, updated_parameters)
            
            # Store the result for future reference
            intermediate_results[f"result_{i}"] = result
            if i == 0:
                intermediate_results["result_of_first_sum"] = result
            elif i == 1:
                intermediate_results["result_of_second_sum"] = result
            
            results.append({
                "tool": tool_name,
                "parameters": updated_parameters,
                "result": result,
                "status": "success"
            })
        except Exception as e:
            results.append({
                "tool": tool_name,
                "parameters": str(tool_call.parameters),
                "error": str(e),
                "status": "error"
            })
            print(f"Error executing tool {tool_name}: {e}")
    
    return results

def execute_tool(tool_name, parameters):
    """Execute a math tool with the given parameters
    
    Args:
        tool_name (str): Name of the tool to execute
        parameters (dict): Parameters for the tool
        
    Returns:
        The result of the tool execution
    """
    if tool_name == "sum":
        return parameters["a"] + parameters["b"]
    elif tool_name == "subtract":
        return parameters["a"] - parameters["b"]
    elif tool_name == "multiply":
        return parameters["a"] * parameters["b"]
    elif tool_name == "divide":
        # Handle different parameter naming conventions
        if "a" in parameters and "b" in parameters:
            numerator = parameters["a"]
            denominator = parameters["b"]
        elif "numerator" in parameters and "denominator" in parameters:
            numerator = parameters["numerator"]
            denominator = parameters["denominator"]
        else:
            raise ValueError("Invalid parameters for divide operation")
            
        if denominator == 0:
            raise ValueError("Cannot divide by zero")
        return numerator / denominator
    else:
        raise ValueError(f"Unknown tool: {tool_name}")

if __name__ == "__main__":
    # Example of using the planner
    paragraph = "i want to multiply 10 by 20"
    tools_list = ["sum", "subtract", "multiply", "divide"]
    
    # Generate the plan
    plan = generate_plan(paragraph, tools_list)
    print(f"Generated plan: {plan}")
    
    # Execute the plan
    results = execute_plan(plan)
    print(f"\nExecution results: {results}")
    
    # Try another example with chained operations
    print("\n\nTrying another example with chained operations:")
    paragraph2 = "add 20 and 30, then divide it by the sum of 2 and 3"
    plan2 = generate_plan(paragraph2, tools_list)
    print(f"Generated plan: {plan2}")
    
    results2 = execute_plan(plan2)
    print(f"\nExecution results: {results2}")
    
    # Try a third example
    print("\n\nTrying a third example:")
    paragraph3 = "multiply 5 by 4, then subtract 3 from the result"
    plan3 = generate_plan(paragraph3, tools_list)
    print(f"Generated plan: {plan3}")
    
    results3 = execute_plan(plan3)
    print(f"\nExecution results: {results3}")